import unittest
import itertools

from concave_hull import hull

import numpy as np


class TestPairs(unittest.TestCase):
    def test_two(self):
        items = [1, 5]
        expected = [(1, 5)]
        actual = hull.pairs(items)
        self.assertEqual(actual, expected)

    def test_five(self):
        items = [1, 2, 3, 6, 7]
        expected = [(1, 2), (2, 3), (3, 6), (6, 7)]
        actual = hull.pairs(items)
        self.assertEqual(actual, expected)


class TestOrderEdges(unittest.TestCase):
    def assert_ordered(self, edges, original):
        for ((v1, v2), (w1, w2)) in hull.pairs(edges):
            self.assertEqual(v2, w1)
        self.assertEqual(hull.get_vertices_set(edges), hull.get_vertices_set(original))

    def test_ordered(self):
        edges = [
            ((1, 5), (2, 3)),
            ((2, 3), (5, 7)),
            ((5, 7), (7, 9)),
            ((7, 9), (1, 5))
        ]
        actual = hull.order_edges(edges)
        self.assert_ordered(actual, edges)

    def test_not_ordered(self):
        edges = [
            ((2, 3), (1, 5)),
            ((2, 3), (5, 7)),
            ((7, 9), (5, 7)),
            ((7, 9), (1, 5))
        ]
        actual = hull.order_edges(edges)
        self.assert_ordered(actual, edges)

    def test_result_from_hull_cshape(self):
        edges = [((0.761786600496278, 0.8596938775510203), (0.7062034739454095, 0.8596938775510203)), ((0.761786600496278, 0.8596938775510203), (0.7478908188585608, 0.8265306122448979)), ((0.7478908188585608, 0.8265306122448979), (0.7320099255583127, 0.8035714285714285)), ((0.7320099255583127, 0.8035714285714285), (0.6903225806451613, 0.7499999999999999)), ((0.6903225806451613, 0.7499999999999999), (0.6406947890818859, 0.7244897959183673)), ((0.6089330024813896, 0.711734693877551), (0.6406947890818859, 0.7244897959183673)), ((0.6089330024813896, 0.711734693877551), (0.5533498759305211, 0.6556122448979591)), ((0.5533498759305211, 0.6556122448979591), (0.5176178660049628, 0.6045918367346939)), ((0.4818858560794045, 0.33418367346938777), (0.5255583126550869, 0.2780612244897959)), ((0.46203473945409435, 0.510204081632653), (0.5176178660049628, 0.6045918367346939)), ((0.44813895781637725, 0.4489795918367347), (0.46203473945409435, 0.510204081632653)), ((0.4540942928039703, 0.38520408163265313), (0.4818858560794045, 0.33418367346938777)), ((0.44813895781637725, 0.4489795918367347), (0.4540942928039703, 0.38520408163265313)), ((0.6625310173697271, 0.17602040816326536), (0.7359801488833747, 0.16836734693877553)), ((0.5255583126550869, 0.2780612244897959), (0.5652605459057072, 0.20918367346938777)), ((0.5652605459057072, 0.20918367346938777), (0.5692307692307693, 0.20408163265306123)), ((0.6228287841191067, 0.17091836734693883), (0.5692307692307693, 0.20408163265306123)), ((0.6228287841191067, 0.17091836734693883), (0.6625310173697271, 0.17602040816326536)), ((0.7359801488833747, 0.16836734693877553), (0.7161290322580646, 0.13775510204081637)), ((0.7161290322580646, 0.13775510204081637), (0.6307692307692307, 0.14795918367346944)), ((0.6307692307692307, 0.14795918367346944), (0.5553349875930521, 0.16836734693877553)), ((0.45012406947890826, 0.2142857142857143), (0.4143920595533499, 0.22704081632653061)), ((0.4957816377171216, 0.201530612244898), (0.45012406947890826, 0.2142857142857143)), ((0.4957816377171216, 0.201530612244898), (0.5553349875930521, 0.16836734693877553)), ((0.4143920595533499, 0.22704081632653061), (0.38064516129032266, 0.24489795918367352)), ((0.315136476426799, 0.3010204081632653), (0.38064516129032266, 0.24489795918367352)), ((0.315136476426799, 0.3010204081632653), (0.2714640198511167, 0.33673469387755106)), ((0.2714640198511167, 0.33673469387755106), (0.2635235732009925, 0.3545918367346939)), ((0.2635235732009925, 0.3545918367346939), (0.2774193548387097, 0.41581632653061223)), ((0.2357320099255583, 0.5076530612244897), (0.2774193548387097, 0.41581632653061223)), ((0.2853598014888338, 0.5765306122448979), (0.2357320099255583, 0.5076530612244897)), ((0.2853598014888338, 0.5765306122448979), (0.2595533498759305, 0.6581632653061223)), ((0.2595533498759305, 0.6581632653061223), (0.319106699751861, 0.6964285714285714)), ((0.319106699751861, 0.6964285714285714), (0.36674937965260546, 0.7321428571428571)), ((0.39454094292803976, 0.8112244897959183), (0.36674937965260546, 0.7321428571428571)), ((0.39454094292803976, 0.8112244897959183), (0.5156327543424318, 0.8520408163265305)), ((0.6029776674937966, 0.7806122448979591), (0.5156327543424318, 0.8520408163265305)), ((0.6029776674937966, 0.7806122448979591), (0.7062034739454095, 0.8596938775510203))]
        actual = hull.order_edges(edges)
        self.assert_ordered(actual, edges)


class TestEdgesToVertices(unittest.TestCase):
    def test_ordered(self):
        edges = [
            ((1, 5), (2, 3)),
            ((2, 3), (5, 7)),
            ((5, 7), (7, 9)),
            ((7, 9), (1, 5))
        ]
        expected = [(1, 5), (2, 3), (5, 7), (7, 9)]
        actual = hull.edges_to_vertices(edges)
        self.assertEqual(expected, actual)


class TestPolygonArea(unittest.TestCase):
    def test_circle(self):
        x = np.arange(0, 1, 0.00001)
        y = np.sqrt(1-x**2)
        points = list(zip(x, y))
        edges = hull.pairs(points)
        expected_area = np.pi / 4
        actual_area = hull.polygon_area(edges)
        self.assertAlmostEqual(expected_area, actual_area, places=2)

    def test_rectangle(self):
        vertices = [(0, 0), (0, 5), (10, 5), (10, 0), (0, 0)]
        edges = hull.pairs(vertices)
        expected_area = 50
        actual_area = hull.polygon_area(edges)
        self.assertEqual(expected_area, actual_area)